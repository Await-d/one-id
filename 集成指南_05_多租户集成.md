# 多租户集成指南

> 本文档介绍如何在 SaaS 平台和企业版应用中实现多租户认证，包括租户隔离、配置管理和路由策略。

## 📋 目录

- [概述](#概述)
- [租户架构](#租户架构)
- [实现方案](#实现方案)
- [租户路由](#租户路由)
- [最佳实践](#最佳实践)

---

## 🎯 概述

### 什么是多租户？

多租户（Multi-Tenancy）是指多个客户（租户）共享同一个应用实例，但数据和配置完全隔离。

### OneID 的多租户特性

OneID 原生支持多租户架构：

- 🏢 **租户隔离**：用户、客户端、配置完全隔离
- 🎨 **独立品牌**：每个租户可自定义登录页样式
- ⚙️ **灵活配置**：租户级的密码策略、会话配置
- 🔒 **数据隔离**：行级安全（Row-Level Security）

### 使用场景

| 场景 | 说明 | 示例 |
|------|------|------|
| SaaS 平台 | 为企业客户提供独立的认证空间 | Salesforce, Shopify |
| 企业版应用 | 大型企业的不同部门 | 集团下的各子公司 |
| 白标方案 | 为合作伙伴提供带自己品牌的系统 | OEM 软件 |

---

## 🏗️ 租户架构

### 架构模式

#### 模式 1: 共享数据库 + 行级隔离（OneID 默认）

```
┌─────────────────────────────────────┐
│         OneID Database              │
├─────────────────────────────────────┤
│  Users                              │
│  ├─ id, email, tenant_id ◄─────┐   │
│  └─ ...                         │   │
│                                 │   │
│  Clients                        │   │
│  ├─ id, name, tenant_id ◄───────┤   │
│  └─ ...                         │   │
│                                 │   │
│  Settings                       │   │
│  ├─ key, value, tenant_id ◄─────┘   │
│  └─ ...                             │
└─────────────────────────────────────┘
```

**特点**：
- ✅ 成本最低
- ✅ 维护简单
- ✅ 资源利用率高
- ⚠️ 需要严格的安全控制

#### 模式 2: 独立数据库（未来支持）

```
Tenant A → Database A
Tenant B → Database B
Tenant C → Database C
```

**特点**：
- ✅ 数据完全隔离
- ✅ 可独立备份恢复
- ⚠️ 成本较高
- ⚠️ 维护复杂

---

### 租户数据模型

```csharp
// OneID.Shared/Domain/Tenant.cs

public class Tenant
{
    public Guid Id { get; set; }
    public string Name { get; set; }            // 租户名称
    public string Slug { get; set; }            // URL 标识（唯一）
    public string? Domain { get; set; }         // 自定义域名
    public bool IsActive { get; set; }          // 是否激活
    
    // 品牌配置
    public string? LogoUrl { get; set; }
    public string? PrimaryColor { get; set; }
    public string? BackgroundColor { get; set; }
    
    // 订阅信息
    public string Plan { get; set; }            // 套餐类型
    public int MaxUsers { get; set; }           // 用户数量限制
    public DateTime? SubscriptionExpiresAt { get; set; }
    
    // 审计字段
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}
```

---

## 🚀 实现方案

### 方案 1: 子域名路由（推荐）

**特点**：每个租户有独立的子域名

**示例**：
- `acme.yourdomain.com` → Acme 公司
- `contoso.yourdomain.com` → Contoso 公司

#### 1. 配置 DNS

```
*.yourdomain.com → Your Application IP
```

#### 2. 租户识别中间件

```csharp
// TenantResolutionMiddleware.cs

public class TenantResolutionMiddleware
{
    private readonly RequestDelegate _next;

    public TenantResolutionMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context, AppDbContext dbContext)
    {
        // 从子域名提取租户标识
        var host = context.Request.Host.Host;
        var subdomain = ExtractSubdomain(host);

        if (string.IsNullOrEmpty(subdomain))
        {
            // 主域名，跳过租户识别
            await _next(context);
            return;
        }

        // 查找租户
        var tenant = await dbContext.Tenants
            .FirstOrDefaultAsync(t => t.Slug == subdomain && t.IsActive);

        if (tenant == null)
        {
            context.Response.StatusCode = 404;
            await context.Response.WriteAsync("Tenant not found");
            return;
        }

        // 存储租户上下文
        context.Items["TenantId"] = tenant.Id;
        context.Items["Tenant"] = tenant;

        await _next(context);
    }

    private string? ExtractSubdomain(string host)
    {
        // 示例：acme.yourdomain.com → acme
        var parts = host.Split('.');
        
        if (parts.Length >= 3)
        {
            return parts[0];
        }

        return null;
    }
}
```

#### 3. 租户上下文服务

```csharp
// ITenantContext.cs

public interface ITenantContext
{
    Guid? TenantId { get; }
    Tenant? Tenant { get; }
}

public class TenantContext : ITenantContext
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    public TenantContext(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }

    public Guid? TenantId =>
        _httpContextAccessor.HttpContext?.Items["TenantId"] as Guid?;

    public Tenant? Tenant =>
        _httpContextAccessor.HttpContext?.Items["Tenant"] as Tenant;
}
```

#### 4. 自动过滤查询

```csharp
// AppDbContext.cs

public class AppDbContext : IdentityDbContext<AppUser>
{
    private readonly ITenantContext _tenantContext;

    public AppDbContext(
        DbContextOptions<AppDbContext> options,
        ITenantContext tenantContext) : base(options)
    {
        _tenantContext = tenantContext;
    }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        // 为所有多租户实体添加全局过滤器
        foreach (var entityType in builder.Model.GetEntityTypes())
        {
            var tenantIdProperty = entityType.FindProperty("TenantId");
            if (tenantIdProperty != null)
            {
                var parameter = Expression.Parameter(entityType.ClrType, "e");
                var property = Expression.Property(parameter, "TenantId");
                var tenantId = Expression.Property(
                    Expression.Constant(_tenantContext),
                    nameof(ITenantContext.TenantId)
                );
                
                var body = Expression.Equal(property, tenantId);
                var lambda = Expression.Lambda(body, parameter);

                builder.Entity(entityType.ClrType).HasQueryFilter(lambda);
            }
        }
    }
}
```

---

### 方案 2: 路径路由

**特点**：使用 URL 路径标识租户

**示例**：
- `yourdomain.com/tenants/acme/...`
- `yourdomain.com/tenants/contoso/...`

#### 实现

```csharp
// TenantFromPathMiddleware.cs

public class TenantFromPathMiddleware
{
    private readonly RequestDelegate _next;

    public TenantFromPathMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context, AppDbContext dbContext)
    {
        var path = context.Request.Path.Value;
        
        // 匹配 /tenants/{slug}/...
        var match = Regex.Match(path, @"^/tenants/([^/]+)");
        
        if (!match.Success)
        {
            await _next(context);
            return;
        }

        var slug = match.Groups[1].Value;

        // 查找租户
        var tenant = await dbContext.Tenants
            .FirstOrDefaultAsync(t => t.Slug == slug && t.IsActive);

        if (tenant == null)
        {
            context.Response.StatusCode = 404;
            await context.Response.WriteAsync("Tenant not found");
            return;
        }

        // 存储租户上下文
        context.Items["TenantId"] = tenant.Id;
        context.Items["Tenant"] = tenant;

        // 重写路径（去掉 /tenants/{slug}）
        context.Request.Path = path.Substring(match.Length);

        await _next(context);
    }
}
```

---

### 方案 3: Header 路由

**特点**：通过 HTTP Header 传递租户标识

**示例**：
```http
GET /api/users HTTP/1.1
Host: api.yourdomain.com
X-Tenant-ID: acme
```

#### 实现

```csharp
public class TenantFromHeaderMiddleware
{
    private readonly RequestDelegate _next;

    public TenantFromHeaderMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context, AppDbContext dbContext)
    {
        if (!context.Request.Headers.TryGetValue("X-Tenant-ID", out var tenantSlug))
        {
            await _next(context);
            return;
        }

        var tenant = await dbContext.Tenants
            .FirstOrDefaultAsync(t => t.Slug == tenantSlug && t.IsActive);

        if (tenant == null)
        {
            context.Response.StatusCode = 404;
            await context.Response.WriteAsync("Tenant not found");
            return;
        }

        context.Items["TenantId"] = tenant.Id;
        context.Items["Tenant"] = tenant;

        await _next(context);
    }
}
```

---

## 🔐 租户数据隔离

### 1. Repository 模式

```csharp
// IUserRepository.cs

public interface IUserRepository
{
    Task<AppUser?> GetByIdAsync(string id);
    Task<List<AppUser>> GetAllAsync();
    Task<AppUser> CreateAsync(AppUser user);
}

public class UserRepository : IUserRepository
{
    private readonly AppDbContext _context;
    private readonly ITenantContext _tenantContext;

    public UserRepository(AppDbContext context, ITenantContext tenantContext)
    {
        _context = context;
        _tenantContext = tenantContext;
    }

    public async Task<AppUser?> GetByIdAsync(string id)
    {
        // 自动过滤当前租户的数据
        return await _context.Users
            .FirstOrDefaultAsync(u => u.Id == id && u.TenantId == _tenantContext.TenantId);
    }

    public async Task<List<AppUser>> GetAllAsync()
    {
        // 仅返回当前租户的用户
        return await _context.Users
            .Where(u => u.TenantId == _tenantContext.TenantId)
            .ToListAsync();
    }

    public async Task<AppUser> CreateAsync(AppUser user)
    {
        // 自动设置租户 ID
        user.TenantId = _tenantContext.TenantId;
        
        _context.Users.Add(user);
        await _context.SaveChangesAsync();
        
        return user;
    }
}
```

### 2. API 控制器

```csharp
// UsersController.cs

[ApiController]
[Route("api/users")]
[Authorize]
public class UsersController : ControllerBase
{
    private readonly IUserRepository _userRepository;
    private readonly ITenantContext _tenantContext;

    public UsersController(
        IUserRepository userRepository,
        ITenantContext tenantContext)
    {
        _userRepository = userRepository;
        _tenantContext = tenantContext;
    }

    [HttpGet]
    public async Task<IActionResult> GetUsers()
    {
        // 自动隔离租户数据
        var users = await _userRepository.GetAllAsync();
        
        return Ok(new
        {
            TenantId = _tenantContext.TenantId,
            TenantName = _tenantContext.Tenant?.Name,
            Users = users
        });
    }

    [HttpPost]
    public async Task<IActionResult> CreateUser([FromBody] CreateUserDto dto)
    {
        var user = new AppUser
        {
            Email = dto.Email,
            UserName = dto.Username,
            // TenantId 会在 Repository 中自动设置
        };

        var createdUser = await _userRepository.CreateAsync(user);
        
        return CreatedAtAction(nameof(GetUsers), new { id = createdUser.Id }, createdUser);
    }
}
```

---

## 🎨 租户自定义品牌

### 1. 登录页定制

```typescript
// src/lib/tenantConfig.ts

export interface TenantConfig {
  id: string;
  name: string;
  slug: string;
  logoUrl?: string;
  primaryColor?: string;
  backgroundColor?: string;
}

export async function getTenantConfig(): Promise<TenantConfig | null> {
  // 从子域名获取租户信息
  const subdomain = getSubdomain();
  
  if (!subdomain) {
    return null;
  }

  try {
    const response = await fetch(`http://localhost:5001/api/tenants/by-slug/${subdomain}`);
    
    if (!response.ok) {
      return null;
    }

    return await response.json();
  } catch (error) {
    console.error('Failed to load tenant config:', error);
    return null;
  }
}

function getSubdomain(): string | null {
  const hostname = window.location.hostname;
  const parts = hostname.split('.');
  
  if (parts.length >= 3) {
    return parts[0];
  }
  
  return null;
}
```

```typescript
// src/pages/LoginPage.tsx

export function LoginPage() {
  const [tenantConfig, setTenantConfig] = useState<TenantConfig | null>(null);

  useEffect(() => {
    loadTenantConfig();
  }, []);

  const loadTenantConfig = async () => {
    const config = await getTenantConfig();
    setTenantConfig(config);
    
    // 应用租户样式
    if (config) {
      applyTenantStyles(config);
    }
  };

  const applyTenantStyles = (config: TenantConfig) => {
    if (config.primaryColor) {
      document.documentElement.style.setProperty('--primary-color', config.primaryColor);
    }
    if (config.backgroundColor) {
      document.documentElement.style.setProperty('--bg-color', config.backgroundColor);
    }
  };

  return (
    <div className="login-page">
      {tenantConfig?.logoUrl && (
        <img src={tenantConfig.logoUrl} alt={tenantConfig.name} />
      )}
      
      <h1>欢迎登录 {tenantConfig?.name || 'OneID'}</h1>
      
      {/* 登录表单 */}
    </div>
  );
}
```

### 2. 动态样式

```css
/* tenant-styles.css */

:root {
  --primary-color: #3b82f6;
  --bg-color: #ffffff;
  --text-color: #1f2937;
}

.btn-primary {
  background-color: var(--primary-color);
}

.login-page {
  background-color: var(--bg-color);
  color: var(--text-color);
}
```

---

## 📊 租户管理 API

### 创建租户

```typescript
// POST /api/tenants
const newTenant = await fetch('http://localhost:5002/api/tenants', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${adminToken}`,
  },
  body: JSON.stringify({
    name: 'Acme Corporation',
    slug: 'acme',
    domain: 'acme.com',
    plan: 'enterprise',
    maxUsers: 1000,
  }),
});
```

### 查询租户

```typescript
// GET /api/tenants/{id}
const tenant = await fetch(`http://localhost:5002/api/tenants/${tenantId}`, {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
  },
});
```

### 更新租户配置

```typescript
// PUT /api/tenants/{id}
await fetch(`http://localhost:5002/api/tenants/${tenantId}`, {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${adminToken}`,
  },
  body: JSON.stringify({
    logoUrl: 'https://cdn.example.com/logos/acme.png',
    primaryColor: '#ff0000',
    maxUsers: 2000,
  }),
});
```

---

## ✅ 最佳实践

### 1. 租户数据安全

```csharp
// ✅ 好的做法：使用全局查询过滤器
protected override void OnModelCreating(ModelBuilder builder)
{
    builder.Entity<AppUser>()
        .HasQueryFilter(u => u.TenantId == _tenantContext.TenantId);
}

// ❌ 坏的做法：手动过滤（容易遗漏）
var users = await _context.Users
    .Where(u => u.TenantId == tenantId) // 容易忘记
    .ToListAsync();
```

### 2. 跨租户操作保护

```csharp
// ✅ 好的做法：验证租户权限
public async Task<AppUser?> GetUserAsync(string userId)
{
    var user = await _context.Users.FindAsync(userId);
    
    if (user != null && user.TenantId != _tenantContext.TenantId)
    {
        throw new UnauthorizedAccessException("Access denied");
    }
    
    return user;
}
```

### 3. 租户配额管理

```csharp
// 检查用户数量限制
public async Task<bool> CanCreateUser()
{
    var tenant = _tenantContext.Tenant;
    var currentUserCount = await _context.Users
        .CountAsync(u => u.TenantId == tenant.Id);
    
    return currentUserCount < tenant.MaxUsers;
}
```

### 4. 性能优化

```csharp
// ✅ 缓存租户配置
private readonly IMemoryCache _cache;

public async Task<Tenant?> GetTenantAsync(Guid tenantId)
{
    return await _cache.GetOrCreateAsync(
        $"tenant:{tenantId}",
        async entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10);
            return await _context.Tenants.FindAsync(tenantId);
        }
    );
}
```

---

## 🔧 故障排除

### 问题 1: 租户识别失败

**症状**：无法正确识别租户

**排查**：
1. 检查中间件注册顺序
2. 验证 DNS 配置
3. 查看日志中的 Host 信息

### 问题 2: 跨租户数据泄漏

**原因**：查询过滤器未生效

**解决**：
1. 确保所有实体都有 `TenantId` 字段
2. 检查全局查询过滤器配置
3. 使用 Repository 模式统一数据访问

### 问题 3: 性能问题

**原因**：频繁查询租户信息

**解决**：
1. 启用租户配置缓存
2. 使用 Connection Pooling
3. 考虑使用独立数据库模式

---

## 📚 相关资源

- [标准 OIDC 集成](./集成指南_01_标准OIDC集成.md)
- [账号统一管理](./集成指南_03_账号统一管理.md)
- [Multi-Tenancy Patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns/multi-tenancy)

---

## 🎯 总结

**多租户集成的关键要点**：

1. ✅ 选择合适的租户识别方式（子域名/路径/Header）
2. ✅ 实施严格的数据隔离
3. ✅ 使用全局查询过滤器
4. ✅ 提供租户级配置管理
5. ✅ 监控租户配额和使用情况
6. ✅ 优化性能（缓存、索引）

**OneID 的多租户优势**：

- 🎯 开箱即用的租户隔离
- 🎨 灵活的品牌定制
- ⚙️ 完整的租户管理 API
- 🔒 行级数据安全

Happy Building! 🚀

