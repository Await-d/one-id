# 自定义登录页集成指南

> 本文档介绍如何在你自己的应用中实现登录页，同时支持本地登录和第三方快捷登录（GitHub、Google、Gitee、微信等）。

## 📋 目录

- [概述](#概述)
- [实现原理](#实现原理)
- [集成步骤](#集成步骤)
- [完整示例](#完整示例)
- [高级功能](#高级功能)
- [最佳实践](#最佳实践)

---

## 🎯 概述

### 什么是自定义登录页集成？

与标准 OIDC 集成不同，自定义登录页集成允许你在**自己的应用**中实现登录界面，而不是跳转到 OneID 的登录页。这种方式特别适合：

- SaaS 应用需要自定义品牌
- 需要完全控制登录体验
- 希望用户留在应用内完成登录
- 需要在登录页添加自定义元素

### 登录页效果

```
你的应用登录页
┌─────────────────────────────────────┐
│      欢迎使用 Your App Logo         │
├─────────────────────────────────────┤
│  用户名: [_______________]          │
│  密码:   [_______________]          │
│         [      登录      ]          │
│                                     │
│  [ 忘记密码？ ]  [ 记住我 ]         │
├─────────────────────────────────────┤
│       快速登录                      │
│                                     │
│  [🐙 GitHub] [🔵 Google] [🟠 Gitee]│
│             [💬 微信]               │
├─────────────────────────────────────┤
│  还没有账号？[ 立即注册 ]           │
└─────────────────────────────────────┘
```

### 对比标准 OIDC 集成

| 特性 | 标准 OIDC | 自定义登录页 |
|------|----------|------------|
| 开发难度 | ⭐ 简单 | ⭐⭐ 中等 |
| 自定义程度 | ❌ 低 | ✅ 高 |
| 品牌一致性 | ❌ 跳转到 OneID | ✅ 完全自定义 |
| 安全性 | ✅ 最高 | ✅ 高 |
| 维护成本 | ✅ 低 | ⚠️ 中 |
| 第三方登录 | ✅ 支持 | ✅ 支持 |

---

## 💡 实现原理

### 用户流程

#### 本地登录流程

```
1. 用户在你的登录页输入用户名密码
   ↓
2. 前端调用 OneID 的 /connect/token 端点
   ↓
3. OneID 验证凭据，返回 Access Token 和 ID Token
   ↓
4. 前端保存 Token，跳转到应用首页
   ↓
5. 登录成功！
```

#### 第三方快捷登录流程

```
1. 用户点击"GitHub 登录"按钮
   ↓
2. 前端直接跳转到 OneID 的外部登录端点
   (绕过 OneID 登录页，直接到 GitHub)
   ↓
3. 用户在 GitHub 完成授权
   ↓
4. GitHub 回调到 OneID
   ↓
5. OneID 创建/绑定用户账号
   ↓
6. OneID 回调到你的应用（携带授权码）
   ↓
7. 你的应用用授权码换取 Token
   ↓
8. 登录成功！
```

### 关键 API 端点

| 端点 | 说明 | 用途 |
|------|------|------|
| `POST /connect/token` | 获取 Token | 用户名密码登录 |
| `GET /api/externalauth/providers` | 获取提供商列表 | 显示第三方登录按钮 |
| `GET /api/externalauth/challenge/{provider}` | 发起外部登录 | 第三方快捷登录 |
| `POST /connect/token` (refresh) | 刷新 Token | Token 续期 |

---

## 🚀 集成步骤

### 步骤 1: 获取可用的第三方登录提供商

```typescript
// src/lib/authApi.ts

export interface ExternalProvider {
  name: string;
  displayName: string;
}

export async function getExternalProviders(): Promise<ExternalProvider[]> {
  try {
    const response = await fetch('http://localhost:5001/api/externalauth/providers');
    
    if (!response.ok) {
      throw new Error('Failed to load external providers');
    }
    
    const providers = await response.json();
    return providers;
  } catch (error) {
    console.error('Error loading external providers:', error);
    return [];
  }
}
```

---

### 步骤 2: 实现本地登录

```typescript
// src/lib/authApi.ts

export interface LoginCredentials {
  username: string;
  password: string;
}

export interface TokenResponse {
  access_token: string;
  id_token: string;
  token_type: string;
  expires_in: number;
  refresh_token?: string;
  scope: string;
}

export async function loginWithPassword(
  credentials: LoginCredentials
): Promise<TokenResponse> {
  const params = new URLSearchParams();
  params.append('grant_type', 'password');
  params.append('username', credentials.username);
  params.append('password', credentials.password);
  params.append('client_id', 'your-client-id');
  params.append('client_secret', 'your-client-secret'); // 仅服务端应用需要
  params.append('scope', 'openid profile email');

  const response = await fetch('http://localhost:5001/connect/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: params.toString(),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error_description || '登录失败');
  }

  const tokenResponse: TokenResponse = await response.json();
  
  // 保存 Token
  localStorage.setItem('access_token', tokenResponse.access_token);
  localStorage.setItem('id_token', tokenResponse.id_token);
  if (tokenResponse.refresh_token) {
    localStorage.setItem('refresh_token', tokenResponse.refresh_token);
  }
  
  // 计算过期时间
  const expiresAt = Date.now() + tokenResponse.expires_in * 1000;
  localStorage.setItem('expires_at', expiresAt.toString());
  
  return tokenResponse;
}
```

---

### 步骤 3: 实现第三方快捷登录

```typescript
// src/lib/authApi.ts

export function loginWithProvider(providerName: string, returnUrl?: string) {
  // 保存当前路径，稍后返回
  if (returnUrl) {
    sessionStorage.setItem('post_login_redirect', returnUrl);
  }
  
  // 构造回调 URL
  const callbackUrl = `${window.location.origin}/auth/callback`;
  
  // 跳转到 OneID 的外部登录端点
  // OneID 会直接重定向到第三方（例如 GitHub）
  window.location.href = 
    `http://localhost:5001/api/externalauth/challenge/${providerName}?returnUrl=${encodeURIComponent(callbackUrl)}`;
}
```

---

### 步骤 4: 处理第三方登录回调

```typescript
// src/pages/AuthCallbackPage.tsx

import React, { useEffect, useState } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';

export function AuthCallbackPage() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const handleCallback = async () => {
      // 检查是否有错误
      const errorParam = searchParams.get('error');
      if (errorParam) {
        setError(searchParams.get('error_description') || errorParam);
        return;
      }

      // 获取授权码
      const code = searchParams.get('code');
      if (!code) {
        setError('未收到授权码');
        return;
      }

      try {
        // 用授权码换取 Token
        await exchangeCodeForToken(code);
        
        // 跳转到之前的页面
        const redirectUrl = sessionStorage.getItem('post_login_redirect') || '/';
        sessionStorage.removeItem('post_login_redirect');
        navigate(redirectUrl);
      } catch (err: any) {
        setError(err.message);
      }
    };

    handleCallback();
  }, [searchParams, navigate]);

  if (error) {
    return (
      <div className="error-page">
        <h2>登录失败</h2>
        <p>{error}</p>
        <button onClick={() => navigate('/login')}>返回登录</button>
      </div>
    );
  }

  return (
    <div className="loading-page">
      <p>正在处理登录，请稍候...</p>
    </div>
  );
}

// 用授权码换取 Token
async function exchangeCodeForToken(code: string): Promise<void> {
  const params = new URLSearchParams();
  params.append('grant_type', 'authorization_code');
  params.append('code', code);
  params.append('client_id', 'your-client-id');
  params.append('client_secret', 'your-client-secret'); // 仅服务端应用
  params.append('redirect_uri', `${window.location.origin}/auth/callback`);

  const response = await fetch('http://localhost:5001/connect/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: params.toString(),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error_description || '获取 Token 失败');
  }

  const tokenResponse = await response.json();
  
  // 保存 Token
  localStorage.setItem('access_token', tokenResponse.access_token);
  localStorage.setItem('id_token', tokenResponse.id_token);
  if (tokenResponse.refresh_token) {
    localStorage.setItem('refresh_token', tokenResponse.refresh_token);
  }
  
  const expiresAt = Date.now() + tokenResponse.expires_in * 1000;
  localStorage.setItem('expires_at', expiresAt.toString());
}
```

---

### 步骤 5: 实现登出

```typescript
// src/lib/authApi.ts

export function logout() {
  // 清除本地 Token
  localStorage.removeItem('access_token');
  localStorage.removeItem('id_token');
  localStorage.removeItem('refresh_token');
  localStorage.removeItem('expires_at');
  
  // 可选：调用 OneID 的登出端点（全局登出）
  // window.location.href = 'http://localhost:5001/connect/endsession';
  
  // 跳转到登录页
  window.location.href = '/login';
}
```

---

### 步骤 6: 刷新 Token

```typescript
// src/lib/authApi.ts

export async function refreshAccessToken(): Promise<TokenResponse> {
  const refreshToken = localStorage.getItem('refresh_token');
  
  if (!refreshToken) {
    throw new Error('No refresh token available');
  }

  const params = new URLSearchParams();
  params.append('grant_type', 'refresh_token');
  params.append('refresh_token', refreshToken);
  params.append('client_id', 'your-client-id');
  params.append('client_secret', 'your-client-secret');

  const response = await fetch('http://localhost:5001/connect/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: params.toString(),
  });

  if (!response.ok) {
    // Refresh token 失效，需要重新登录
    logout();
    throw new Error('Refresh token expired');
  }

  const tokenResponse: TokenResponse = await response.json();
  
  // 更新 Token
  localStorage.setItem('access_token', tokenResponse.access_token);
  const expiresAt = Date.now() + tokenResponse.expires_in * 1000;
  localStorage.setItem('expires_at', expiresAt.toString());
  
  return tokenResponse;
}

// 检查 Token 是否即将过期，自动刷新
export async function ensureValidToken(): Promise<string> {
  const accessToken = localStorage.getItem('access_token');
  const expiresAt = localStorage.getItem('expires_at');
  
  if (!accessToken || !expiresAt) {
    throw new Error('Not logged in');
  }
  
  // 如果 Token 在 5 分钟内过期，刷新它
  if (Date.now() > parseInt(expiresAt) - 5 * 60 * 1000) {
    console.log('Token expiring soon, refreshing...');
    const tokenResponse = await refreshAccessToken();
    return tokenResponse.access_token;
  }
  
  return accessToken;
}
```

---

## 💻 完整示例

### 登录页面组件

```typescript
// src/pages/LoginPage.tsx

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  loginWithPassword, 
  loginWithProvider, 
  getExternalProviders,
  type ExternalProvider 
} from '../lib/authApi';

export function LoginPage() {
  const navigate = useNavigate();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [providers, setProviders] = useState<ExternalProvider[]>([]);

  // 加载外部登录提供商
  useEffect(() => {
    const loadProviders = async () => {
      const list = await getExternalProviders();
      setProviders(list);
    };
    loadProviders();
  }, []);

  // 本地登录
  const handleLocalLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      await loginWithPassword({ username, password });
      navigate('/dashboard'); // 登录成功，跳转到首页
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  // 第三方登录
  const handleExternalLogin = (providerName: string) => {
    loginWithProvider(providerName, '/dashboard');
  };

  // 图标组件
  const getProviderIcon = (name: string) => {
    switch (name.toLowerCase()) {
      case 'github':
        return '🐙';
      case 'google':
        return '🔵';
      case 'gitee':
        return '🟠';
      case 'wechat':
        return '💬';
      default:
        return '🔑';
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow-md">
        {/* 标题 */}
        <div className="text-center">
          <h2 className="text-3xl font-bold text-gray-900">欢迎回来</h2>
          <p className="mt-2 text-sm text-gray-600">登录到您的账号</p>
        </div>

        {/* 错误提示 */}
        {error && (
          <div className="bg-red-50 border border-red-200 text-red-800 px-4 py-3 rounded">
            {error}
          </div>
        )}

        {/* 本地登录表单 */}
        <form onSubmit={handleLocalLogin} className="mt-8 space-y-6">
          <div>
            <label htmlFor="username" className="block text-sm font-medium text-gray-700">
              用户名或邮箱
            </label>
            <input
              id="username"
              type="text"
              required
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              placeholder="请输入用户名或邮箱"
            />
          </div>

          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              密码
            </label>
            <input
              id="password"
              type="password"
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              placeholder="请输入密码"
            />
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                id="remember-me"
                type="checkbox"
                className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
              />
              <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900">
                记住我
              </label>
            </div>

            <div className="text-sm">
              <a href="/forgot-password" className="font-medium text-blue-600 hover:text-blue-500">
                忘记密码？
              </a>
            </div>
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
          >
            {loading ? '登录中...' : '登录'}
          </button>
        </form>

        {/* 第三方快捷登录 */}
        {providers.length > 0 && (
          <>
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-gray-300"></div>
              </div>
              <div className="relative flex justify-center text-sm">
                <span className="px-2 bg-white text-gray-500">或者快速登录</span>
              </div>
            </div>

            <div className="grid grid-cols-2 gap-3">
              {providers.map((provider) => (
                <button
                  key={provider.name}
                  onClick={() => handleExternalLogin(provider.name)}
                  className="flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                >
                  <span className="text-xl mr-2">{getProviderIcon(provider.name)}</span>
                  {provider.displayName}
                </button>
              ))}
            </div>
          </>
        )}

        {/* 注册链接 */}
        <div className="text-center text-sm">
          <span className="text-gray-600">还没有账号？</span>
          <a href="/register" className="ml-1 font-medium text-blue-600 hover:text-blue-500">
            立即注册
          </a>
        </div>
      </div>
    </div>
  );
}
```

---

## 🎨 高级功能

### 1. 社交账号绑定

允许用户将第三方账号绑定到现有账号：

```typescript
// src/pages/ProfilePage.tsx

export function ProfilePage() {
  const [linkedAccounts, setLinkedAccounts] = useState<string[]>([]);
  const [providers, setProviders] = useState<ExternalProvider[]>([]);

  useEffect(() => {
    loadLinkedAccounts();
    loadProviders();
  }, []);

  const handleBindAccount = (providerName: string) => {
    // 跳转到绑定流程
    loginWithProvider(providerName, '/profile?action=bind');
  };

  const handleUnbindAccount = async (providerName: string) => {
    try {
      const token = await ensureValidToken();
      const response = await fetch(
        `http://localhost:5002/api/users/me/external-logins/${providerName}`,
        {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        }
      );
      
      if (response.ok) {
        alert('解绑成功');
        loadLinkedAccounts();
      }
    } catch (error) {
      console.error('解绑失败:', error);
    }
  };

  return (
    <div className="profile-page">
      <h2>账号绑定</h2>
      <div className="linked-accounts">
        {providers.map(provider => {
          const isLinked = linkedAccounts.includes(provider.name);
          return (
            <div key={provider.name} className="account-item">
              <span>{provider.displayName}</span>
              {isLinked ? (
                <button onClick={() => handleUnbindAccount(provider.name)}>
                  解绑
                </button>
              ) : (
                <button onClick={() => handleBindAccount(provider.name)}>
                  绑定
                </button>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

### 2. 自动 Token 刷新

```typescript
// src/lib/tokenRefresh.ts

let refreshTimer: NodeJS.Timeout | null = null;

export function startTokenRefreshTimer() {
  // 清除已有的定时器
  if (refreshTimer) {
    clearTimeout(refreshTimer);
  }

  const expiresAt = localStorage.getItem('expires_at');
  if (!expiresAt) return;

  const expiresIn = parseInt(expiresAt) - Date.now();
  
  // 在过期前 5 分钟刷新
  const refreshIn = expiresIn - 5 * 60 * 1000;
  
  if (refreshIn > 0) {
    refreshTimer = setTimeout(async () => {
      try {
        await refreshAccessToken();
        console.log('Token 刷新成功');
        startTokenRefreshTimer(); // 重新启动定时器
      } catch (error) {
        console.error('Token 刷新失败:', error);
      }
    }, refreshIn);
  }
}

// 在应用启动时调用
// src/App.tsx
import { startTokenRefreshTimer } from './lib/tokenRefresh';

function App() {
  useEffect(() => {
    startTokenRefreshTimer();
  }, []);
  
  // ...
}
```

### 3. 密码强度验证

```typescript
// src/components/PasswordInput.tsx

import React, { useState } from 'react';

interface PasswordStrength {
  score: number; // 0-4
  feedback: string;
}

function checkPasswordStrength(password: string): PasswordStrength {
  let score = 0;
  const feedback: string[] = [];

  // 长度检查
  if (password.length >= 8) score++;
  else feedback.push('至少8个字符');

  // 包含大写字母
  if (/[A-Z]/.test(password)) score++;
  else feedback.push('包含大写字母');

  // 包含小写字母
  if (/[a-z]/.test(password)) score++;
  else feedback.push('包含小写字母');

  // 包含数字
  if (/\d/.test(password)) score++;
  else feedback.push('包含数字');

  // 包含特殊字符
  if (/[^A-Za-z0-9]/.test(password)) score++;

  return {
    score,
    feedback: feedback.join(', ') || '密码强度很好',
  };
}

export function PasswordInput({ value, onChange }: any) {
  const strength = checkPasswordStrength(value);
  const colors = ['bg-red-500', 'bg-orange-500', 'bg-yellow-500', 'bg-blue-500', 'bg-green-500'];

  return (
    <div>
      <input
        type="password"
        value={value}
        onChange={onChange}
        className="w-full px-3 py-2 border rounded"
      />
      
      {/* 密码强度指示器 */}
      <div className="mt-2">
        <div className="flex space-x-1">
          {[...Array(5)].map((_, i) => (
            <div
              key={i}
              className={`h-2 flex-1 rounded ${
                i < strength.score ? colors[strength.score] : 'bg-gray-200'
              }`}
            />
          ))}
        </div>
        <p className="text-sm text-gray-600 mt-1">{strength.feedback}</p>
      </div>
    </div>
  );
}
```

---

## ✅ 最佳实践

### 1. 安全性

- ✅ 使用 HTTPS（生产环境）
- ✅ 不要在前端暴露 Client Secret
- ✅ 使用 HttpOnly Cookie 存储 Refresh Token
- ✅ 实现 CSRF 保护
- ✅ 设置合理的 Token 过期时间

### 2. 用户体验

- ✅ 提供清晰的错误提示
- ✅ 加载状态反馈
- ✅ 记住用户选择的登录方式
- ✅ 支持"记住我"功能
- ✅ 自动 Token 刷新

### 3. 性能优化

- ✅ 缓存外部提供商列表
- ✅ 防抖表单提交
- ✅ 懒加载第三方 SDK

### 4. 可访问性

- ✅ 使用语义化 HTML
- ✅ 添加 ARIA 标签
- ✅ 支持键盘导航
- ✅ 提供屏幕阅读器支持

---

## 🔧 故障排除

### 问题 1: Resource Owner Password 被禁用

**错误**：`unsupported_grant_type`

**原因**：OneID 默认不启用 Resource Owner Password Credentials 流程（不安全）

**解决**：

1. 在 OneID Admin Portal 中启用客户端的 Password 授权类型
2. 或者改用标准 OIDC 流程（推荐）

### 问题 2: 跨域问题

**错误**：`CORS policy: No 'Access-Control-Allow-Origin' header`

**解决**：配置 OneID 的 CORS：

```csharp
// OneID.Identity/Program.cs
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        policy.WithOrigins("http://localhost:3000")
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});
```

### 问题 3: Token 存储安全性

**问题**：Access Token 存储在 localStorage，容易被 XSS 攻击

**建议方案**：

1. 使用 HttpOnly Cookie（需要后端配合）
2. 使用内存存储 + Session Storage
3. 实施严格的 CSP 策略

---

## 📚 相关资源

- [标准 OIDC 集成](./集成指南_01_标准OIDC集成.md)
- [账号统一管理](./集成指南_03_账号统一管理.md)
- [OAuth 2.0 规范](https://oauth.net/2/)
- [OWASP 安全指南](https://owasp.org/)

---

## 🎯 总结

**自定义登录页集成适合**：

- ✅ SaaS 应用
- ✅ 需要完全自定义 UI/UX
- ✅ 希望用户留在应用内
- ✅ 有前端开发能力

**如果你只需要简单的集成，推荐使用** [标准 OIDC 集成](./集成指南_01_标准OIDC集成.md)。

Happy Coding! 🚀

