# 账号统一管理指南

> 本文档介绍如何在现有用户系统与 OneID 之间实现账号统一管理，包括账号迁移、绑定策略和混合认证模式。

## 📋 目录

- [概述](#概述)
- [三种账号管理模式](#三种账号管理模式)
- [账号迁移策略](#账号迁移策略)
- [实现方案](#实现方案)
- [最佳实践](#最佳实践)

---

## 🎯 概述

### 为什么需要账号统一管理？

当你的应用已经有一套用户系统，但希望引入 OneID 进行统一认证时，会面临以下问题：

- 🤔 现有用户如何迁移到 OneID？
- 🤔 用户使用第三方登录时，如何关联到现有账号？
- 🤔 如何同时支持本地账号和 OneID 账号登录？
- 🤔 如何确保用户数据的一致性？

本文档提供了完整的解决方案。

### 核心概念

#### sub (Subject Identifier)

OIDC 标准中的用户唯一标识符，由 OneID 颁发。这是关联用户账号的核心字段。

```json
{
  "sub": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "name": "张三"
}
```

**关键特性**：
- ✅ 全局唯一
- ✅ 永不改变
- ✅ 即使用户修改邮箱、用户名，`sub` 也不会变

#### 账号关联表

在你的数据库中建立 OneID `sub` 与本地用户 ID 的映射关系：

```sql
CREATE TABLE user_identity_mappings (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    local_user_id BIGINT NOT NULL,
    oneid_sub VARCHAR(255) NOT NULL,
    provider VARCHAR(50), -- 'OneID', 'GitHub', 'Google' 等
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_oneid_sub (oneid_sub),
    KEY idx_local_user_id (local_user_id),
    FOREIGN KEY (local_user_id) REFERENCES users(id)
);
```

---

## 📊 三种账号管理模式

### 模式 1: 完全托管模式（推荐）

**适用场景**：新系统或可以完全迁移的系统

**特点**：
- 所有账号由 OneID 管理
- 本地系统只存储业务数据
- 用户信息从 OneID 同步

**架构**：

```
┌─────────────────┐
│   你的应用      │
│                 │
│  业务数据表     │
│  ├─ orders      │
│  ├─ products    │
│  └─ ...         │
└────────┬────────┘
         │
         ↓ (通过 sub 关联)
┌─────────────────┐
│     OneID       │
│                 │
│  用户账号表     │
│  ├─ users       │
│  ├─ roles       │
│  └─ permissions │
└─────────────────┘
```

**数据模型**：

```typescript
// 你的应用数据库
interface Order {
  id: string;
  oneid_sub: string; // 关联到 OneID 的 sub
  product_id: string;
  amount: number;
  created_at: Date;
}

// 获取用户信息时，从 OneID 获取
async function getUserInfo(sub: string) {
  const token = await getAccessToken();
  const response = await fetch('http://localhost:5001/connect/userinfo', {
    headers: { 'Authorization': `Bearer ${token}` }
  });
  return response.json();
}
```

**优点**：
- ✅ 架构最简单
- ✅ 数据一致性最好
- ✅ 维护成本最低

**缺点**：
- ⚠️ 需要迁移现有账号数据

---

### 模式 2: 关联模式（推荐用于迁移）

**适用场景**：已有用户系统，逐步迁移到 OneID

**特点**：
- 保留现有用户表
- OneID `sub` 与本地 User ID 建立关联
- 支持双向查询

**架构**：

```
┌─────────────────────────────────┐
│         你的应用                │
│                                 │
│  ┌─────────┐    ┌────────────┐ │
│  │ Users   │◄──►│ Mappings   │ │
│  │         │    │            │ │
│  │ id      │    │local_user  │ │
│  │ email   │    │oneid_sub   │ │
│  │ name    │    │provider    │ │
│  └─────────┘    └──────┬─────┘ │
└────────────────────────┼───────┘
                         │
                         ↓ (通过 sub 关联)
                  ┌─────────────┐
                  │   OneID     │
                  │             │
                  │  ┌────────┐ │
                  │  │ Users  │ │
                  │  │        │ │
                  │  │ sub    │ │
                  │  │ email  │ │
                  │  └────────┘ │
                  └─────────────┘
```

**数据模型**：

```typescript
// 本地用户表
interface LocalUser {
  id: number;
  email: string;
  username: string;
  password_hash: string; // 仍然保留
  created_at: Date;
}

// 关联表
interface UserIdentityMapping {
  id: number;
  local_user_id: number;
  oneid_sub: string;
  provider: 'OneID' | 'GitHub' | 'Google' | 'Gitee';
  created_at: Date;
}

// 查询逻辑
async function getUserByOneIdSub(sub: string): Promise<LocalUser | null> {
  const mapping = await db.query(
    'SELECT local_user_id FROM user_identity_mappings WHERE oneid_sub = ?',
    [sub]
  );
  
  if (!mapping) return null;
  
  return await db.query(
    'SELECT * FROM users WHERE id = ?',
    [mapping.local_user_id]
  );
}
```

**优点**：
- ✅ 平滑迁移
- ✅ 支持混合认证（本地密码 + OneID）
- ✅ 数据隔离，业务不受影响

**缺点**：
- ⚠️ 需要维护两套用户数据
- ⚠️ 数据同步复杂度高

---

### 模式 3: 纯 SSO 模式

**适用场景**：OneID 仅用于认证，用户数据完全由本地管理

**特点**：
- OneID 只负责认证
- 首次登录时自动创建本地账号
- 本地系统完全控制用户信息

**架构**：

```
用户登录 → OneID 认证 → 返回 Token → 本地系统验证 Token → 创建/更新本地用户
```

**实现**：

```typescript
// 处理 OneID 登录回调
async function handleOidcCallback(code: string) {
  // 1. 获取 Token
  const tokenResponse = await exchangeCodeForToken(code);
  
  // 2. 解析 ID Token，获取 sub 和基本信息
  const idToken = parseJwt(tokenResponse.id_token);
  const { sub, email, name } = idToken;
  
  // 3. 查找或创建本地用户
  let localUser = await findUserBySub(sub);
  
  if (!localUser) {
    // 首次登录，创建本地账号
    localUser = await createLocalUser({
      oneid_sub: sub,
      email: email,
      name: name,
    });
    
    console.log('创建新用户:', localUser);
  } else {
    // 更新用户信息（可选）
    await updateUserInfo(localUser.id, { email, name });
  }
  
  // 4. 创建本地会话
  await createSession(localUser.id);
  
  return localUser;
}
```

**优点**：
- ✅ 最大的灵活性
- ✅ 本地完全控制用户数据
- ✅ OneID 故障不影响现有用户

**缺点**：
- ⚠️ 需要手动同步用户信息
- ⚠️ 无法使用 OneID 的用户管理功能

---

## 🔄 账号迁移策略

### 策略 1: 一次性批量迁移

**适用场景**：用户量不大（< 10万），可以计划停机维护

**步骤**：

#### 1. 准备迁移脚本

```typescript
// migrate-users.ts

import { UserManager } from 'oidc-client-ts';
import { db } from './database';

interface LocalUser {
  id: number;
  email: string;
  username: string;
  password_hash: string;
}

async function migrateUsers() {
  console.log('开始迁移用户...');
  
  // 1. 获取所有本地用户
  const localUsers = await db.query<LocalUser[]>('SELECT * FROM users');
  
  console.log(`找到 ${localUsers.length} 个用户`);
  
  for (const localUser of localUsers) {
    try {
      // 2. 在 OneID 中创建用户
      const oneIdUser = await createOneIdUser({
        email: localUser.email,
        username: localUser.username,
        // 注意：密码需要重置或者要求用户重新设置
        requirePasswordReset: true,
      });
      
      // 3. 创建关联记录
      await db.query(
        'INSERT INTO user_identity_mappings (local_user_id, oneid_sub, provider) VALUES (?, ?, ?)',
        [localUser.id, oneIdUser.sub, 'OneID']
      );
      
      console.log(`✓ 迁移成功: ${localUser.email} -> ${oneIdUser.sub}`);
      
    } catch (error) {
      console.error(`✗ 迁移失败: ${localUser.email}`, error);
      // 记录失败的用户，稍后人工处理
      await db.query(
        'INSERT INTO migration_failures (user_id, error) VALUES (?, ?)',
        [localUser.id, error.message]
      );
    }
  }
  
  console.log('迁移完成！');
}

// 执行迁移
migrateUsers().catch(console.error);
```

#### 2. 通知用户

```typescript
// 发送邮件通知
async function notifyUsers() {
  const users = await db.query('SELECT email FROM users');
  
  for (const user of users) {
    await sendEmail({
      to: user.email,
      subject: '系统升级通知 - 请重置密码',
      body: `
        亲爱的用户：
        
        我们已升级到统一身份认证系统。
        首次登录时，请使用"忘记密码"功能重置您的密码。
        
        感谢您的配合！
      `,
    });
  }
}
```

---

### 策略 2: 渐进式迁移（推荐）

**适用场景**：用户量大，无法停机，需要平滑过渡

**原理**：用户首次登录时自动迁移

**步骤**：

#### 1. 实现混合认证

```typescript
// auth-service.ts

export async function authenticateUser(username: string, password: string) {
  // 1. 先检查用户是否已迁移到 OneID
  const mapping = await db.query(
    'SELECT oneid_sub FROM user_identity_mappings m ' +
    'JOIN users u ON m.local_user_id = u.id ' +
    'WHERE u.username = ? OR u.email = ?',
    [username, username]
  );
  
  if (mapping) {
    // 已迁移，使用 OneID 认证
    return await authenticateWithOneId(username, password);
  }
  
  // 2. 未迁移，使用本地认证
  const localUser = await authenticateLocal(username, password);
  
  if (!localUser) {
    throw new Error('用户名或密码错误');
  }
  
  // 3. 认证成功，自动迁移到 OneID
  const oneIdUser = await migrateUserToOneId(localUser, password);
  
  console.log(`自动迁移用户: ${localUser.email} -> ${oneIdUser.sub}`);
  
  // 4. 创建关联
  await db.query(
    'INSERT INTO user_identity_mappings (local_user_id, oneid_sub, provider) VALUES (?, ?, ?)',
    [localUser.id, oneIdUser.sub, 'OneID']
  );
  
  // 5. 返回 OneID Token
  return await authenticateWithOneId(username, password);
}

// 本地认证（旧系统）
async function authenticateLocal(username: string, password: string) {
  const user = await db.query(
    'SELECT * FROM users WHERE username = ? OR email = ?',
    [username, username]
  );
  
  if (!user) return null;
  
  const isValid = await bcrypt.compare(password, user.password_hash);
  return isValid ? user : null;
}

// OneID 认证
async function authenticateWithOneId(username: string, password: string) {
  const response = await fetch('http://localhost:5001/connect/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'password',
      username: username,
      password: password,
      client_id: 'your-client-id',
      client_secret: 'your-client-secret',
      scope: 'openid profile email',
    }),
  });
  
  if (!response.ok) {
    throw new Error('OneID 认证失败');
  }
  
  return await response.json();
}

// 迁移用户到 OneID
async function migrateUserToOneId(localUser: any, password: string) {
  const response = await fetch('http://localhost:5002/api/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${ADMIN_TOKEN}`,
    },
    body: JSON.stringify({
      email: localUser.email,
      username: localUser.username,
      password: password, // 使用原密码
      name: localUser.name,
    }),
  });
  
  if (!response.ok) {
    throw new Error('迁移用户失败');
  }
  
  return await response.json();
}
```

#### 2. 进度监控

```typescript
// 迁移进度统计
async function getMigrationProgress() {
  const totalUsers = await db.query('SELECT COUNT(*) as count FROM users');
  const migratedUsers = await db.query(
    'SELECT COUNT(*) as count FROM user_identity_mappings'
  );
  
  const progress = (migratedUsers.count / totalUsers.count) * 100;
  
  console.log(`迁移进度: ${progress.toFixed(2)}%`);
  console.log(`已迁移: ${migratedUsers.count} / ${totalUsers.count}`);
  
  return {
    total: totalUsers.count,
    migrated: migratedUsers.count,
    percentage: progress,
  };
}
```

---

### 策略 3: 双系统并行

**适用场景**：需要长期共存两套系统

**实现**：

```typescript
// 登录时让用户选择认证方式
export function LoginPage() {
  const [authMode, setAuthMode] = useState<'local' | 'oneid'>('oneid');
  
  return (
    <div>
      <div className="auth-mode-selector">
        <button onClick={() => setAuthMode('local')}>
          使用原账号登录
        </button>
        <button onClick={() => setAuthMode('oneid')}>
          使用统一账号登录
        </button>
      </div>
      
      {authMode === 'local' ? (
        <LocalLoginForm />
      ) : (
        <OneIdLoginForm />
      )}
    </div>
  );
}
```

---

## 🛠️ 实现方案

### 方案 1: 通过邮箱自动绑定

**原理**：用户使用第三方登录时，如果邮箱匹配，自动绑定到现有账号

```typescript
// handle-external-login.ts

async function handleExternalLoginCallback(sub: string, email: string, provider: string) {
  // 1. 检查是否已有关联
  let mapping = await db.query(
    'SELECT * FROM user_identity_mappings WHERE oneid_sub = ?',
    [sub]
  );
  
  if (mapping) {
    // 已关联，直接登录
    return await loginUser(mapping.local_user_id);
  }
  
  // 2. 通过邮箱查找本地用户
  const localUser = await db.query(
    'SELECT * FROM users WHERE email = ?',
    [email]
  );
  
  if (localUser) {
    // 3. 邮箱匹配，自动绑定
    await db.query(
      'INSERT INTO user_identity_mappings (local_user_id, oneid_sub, provider) VALUES (?, ?, ?)',
      [localUser.id, sub, provider]
    );
    
    console.log(`自动绑定账号: ${email} -> ${provider}`);
    
    // 发送通知
    await sendEmail({
      to: email,
      subject: '账号绑定通知',
      body: `您的账号已成功绑定到 ${provider}`,
    });
    
    return await loginUser(localUser.id);
  }
  
  // 4. 新用户，创建账号
  const newUser = await db.query(
    'INSERT INTO users (email, name) VALUES (?, ?)',
    [email, email.split('@')[0]]
  );
  
  await db.query(
    'INSERT INTO user_identity_mappings (local_user_id, oneid_sub, provider) VALUES (?, ?, ?)',
    [newUser.id, sub, provider]
  );
  
  return await loginUser(newUser.id);
}
```

**安全考虑**：

```typescript
// 邮箱必须经过验证
async function handleExternalLoginCallback(sub: string, email: string, emailVerified: boolean) {
  if (!emailVerified) {
    throw new Error('邮箱未验证，无法自动绑定');
  }
  
  // ... 其他逻辑
}
```

---

### 方案 2: 手动绑定

**原理**：用户主动在个人中心绑定第三方账号

```typescript
// profile-page.tsx

export function ProfilePage() {
  const [linkedAccounts, setLinkedAccounts] = useState([]);
  
  const handleLinkAccount = async (provider: string) => {
    // 1. 发起绑定流程
    sessionStorage.setItem('binding_action', 'link');
    
    // 2. 跳转到 OneID 进行第三方认证
    window.location.href = 
      `http://localhost:5001/api/externalauth/challenge/${provider}?returnUrl=${window.location.origin}/profile/callback`;
  };
  
  return (
    <div>
      <h2>账号绑定</h2>
      <button onClick={() => handleLinkAccount('GitHub')}>
        绑定 GitHub 账号
      </button>
    </div>
  );
}

// 绑定回调处理
async function handleBindingCallback(code: string) {
  const action = sessionStorage.getItem('binding_action');
  
  if (action !== 'link') {
    throw new Error('Invalid binding action');
  }
  
  // 1. 获取 OneID 用户信息
  const tokenResponse = await exchangeCodeForToken(code);
  const idToken = parseJwt(tokenResponse.id_token);
  
  // 2. 关联到当前登录用户
  const currentUser = getCurrentUser();
  
  await db.query(
    'INSERT INTO user_identity_mappings (local_user_id, oneid_sub, provider) VALUES (?, ?, ?)',
    [currentUser.id, idToken.sub, idToken.idp]
  );
  
  alert('绑定成功！');
}
```

---

## ✅ 最佳实践

### 1. 数据一致性

```typescript
// 定期同步用户信息
async function syncUserInfo(userId: number) {
  const mapping = await db.query(
    'SELECT oneid_sub FROM user_identity_mappings WHERE local_user_id = ?',
    [userId]
  );
  
  if (!mapping) return;
  
  // 从 OneID 获取最新信息
  const oneIdUser = await fetchOneIdUser(mapping.oneid_sub);
  
  // 更新本地用户信息
  await db.query(
    'UPDATE users SET email = ?, name = ?, updated_at = NOW() WHERE id = ?',
    [oneIdUser.email, oneIdUser.name, userId]
  );
}
```

### 2. 处理邮箱冲突

```typescript
async function handleEmailConflict(newEmail: string, existingUserId: number) {
  // 策略 1: 拒绝绑定
  throw new Error('该邮箱已被其他账号使用');
  
  // 策略 2: 发送验证邮件，由用户确认合并
  await sendVerificationEmail(newEmail, {
    action: 'merge_account',
    existingUserId,
    newUserId,
  });
}
```

### 3. 审计日志

```typescript
// 记录所有账号变更
async function logAccountChange(action: string, userId: number, details: any) {
  await db.query(
    'INSERT INTO account_audit_logs (user_id, action, details, created_at) VALUES (?, ?, ?, NOW())',
    [userId, action, JSON.stringify(details)]
  );
}

// 使用示例
await logAccountChange('ACCOUNT_LINKED', userId, {
  provider: 'GitHub',
  oneid_sub: sub,
});
```

---

## 📚 相关资源

- [标准 OIDC 集成](./集成指南_01_标准OIDC集成.md)
- [自定义登录页集成](./集成指南_02_自定义登录页集成.md)
- [API 直接集成](./集成指南_04_API直接集成.md)

---

## 🎯 总结

**选择账号管理模式**：

| 场景 | 推荐模式 |
|------|---------|
| 新系统 | 完全托管模式 |
| 现有系统，用户量不大 | 一次性批量迁移 → 完全托管 |
| 现有系统，用户量大 | 渐进式迁移 → 关联模式 |
| 需要保留旧系统 | 双系统并行 → 关联模式 |
| OneID 仅用于认证 | 纯 SSO 模式 |

**关键要点**：

1. ✅ 使用 `sub` 作为唯一标识
2. ✅ 邮箱必须经过验证
3. ✅ 记录详细的审计日志
4. ✅ 提供清晰的用户通知
5. ✅ 制定回滚计划

Happy Integrating! 🚀

